import { Gff3AnnotationParser } from './gff3-parser';
import type { FileParseRequest } from '@shared/parser/types';

// Mock node:fs - 为 CommonJS 模块添加 default export
vi.mock('node:fs', async () => {
  const actual = await import('node:fs');
  return {
    default: {
      ...actual,
      readFileSync: vi.fn()
    }
  };
});

// Mock node:crypto
vi.mock('node:crypto', async () => {
  const actual = await import('node:crypto');
  return {
    default: {
      ...actual,
      randomUUID: vi.fn(() => 'test-uuid-1234-5678-9abc-def0')
    }
  };
});

describe('Gff3AnnotationParser', () => {
  let parser: Gff3AnnotationParser;
  let mockReadFileSync: any;
  let mockRandomUUID: any;
  const mockProjectId = 'test-project-id';

  beforeEach(async () => {
    parser = new Gff3AnnotationParser();
    vi.clearAllMocks();

    const fsModule = await import('node:fs');
    const cryptoModule = await import('node:crypto');
    mockReadFileSync = vi.mocked(fsModule.default.readFileSync);
    mockRandomUUID = vi.mocked(cryptoModule.default.randomUUID);
    mockRandomUUID.mockReturnValue('test-uuid-1234-5678-9abc-def0');
  });

  describe('summary', () => {
    it('应返回正确的解析器摘要', () => {
      const summary = parser.summary();
      expect(summary).toMatchObject({
        format: 'gff3',
        displayName: 'GFF3 注释解析器'
      });
      expect(summary.description).toContain('读取 GFF3');
    });
  });

  describe('canParse', () => {
    it('应正确识别 gff3 格式', () => {
      expect(parser.canParse('gff3')).toBe(true);
      expect(parser.canParse('json')).toBe(false);
      expect(parser.canParse('csv')).toBe(false);
      expect(parser.canParse('genbank')).toBe(false);
    });
  });

  describe('parse', () => {
    it('应解析有效的 GFF3 文件', async () => {
      const gffData = `##gff-version 3
##sequence-region   RefSeq  1  1000
RefSeq\t.\tgene\t100\t200\t.\t+\t.\tID=geneA;Name=gene A
RefSeq\t.\tCDS\t300\t500\t.\t+\t0\tID=cdsA;Parent=geneA;product=hypothetical protein
RefSeq\t.\tgene\t600\t800\t.\t-\t.\tID=geneB;Name=gene B

`;

      mockReadFileSync.mockReturnValueOnce(gffData);

      const request: FileParseRequest = {
        projectId: mockProjectId,
        filePath: 'test.gff3'
      };

      const result = await parser.parse(request);

      expect(result.dataset).toMatchObject({
        projectId: mockProjectId,
        format: 'gff3',
        sourcePath: 'test.gff3',
        meta: {
          recordCount: 3,
          totalLength: 1000
        }
      });

      expect(result.dataset.features).toHaveLength(3);
      expect(result.dataset.features[0]).toMatchObject({
        type: 'gene',
        name: 'gene A',
        start: 100,
        stop: 200,
        strand: 1
      });
      expect(result.dataset.features[2]).toMatchObject({
        strand: -1
      });
    });

    it('应处理负链方向', async () => {
      const gffData = `##gff-version 3
Test\t.\tgene\t100\t200\t.\t-\t.\tID=geneA

`;

      mockReadFileSync.mockReturnValueOnce(gffData);

      const request: FileParseRequest = {
        projectId: mockProjectId,
        filePath: 'test.gff3'
      };

      const result = await parser.parse(request);

      expect(result.dataset.features[0]).toMatchObject({
        strand: -1
      });
    });

    it('应提取属性字段', async () => {
      const gffData = `##gff-version 3
Test\t.\tgene\t100\t200\t.\t+\t.\tID=geneA;Name=Gene A;product=hypothetical protein;note=important

`;

      mockReadFileSync.mockReturnValueOnce(gffData);

      const request: FileParseRequest = {
        projectId: mockProjectId,
        filePath: 'test.gff3'
      };

      const result = await parser.parse(request);

      expect(result.dataset.features[0].qualifiers).toMatchObject({
        ID: 'geneA',
        Name: 'Gene A',
        product: 'hypothetical protein',
        note: 'important'
      });
    });

    it('应处理空 GFF3 文件', async () => {
      const gffData = '##gff-version 3\n';

      mockReadFileSync.mockReturnValueOnce(gffData);

      const request: FileParseRequest = {
        projectId: mockProjectId,
        filePath: 'empty.gff3'
      };

      const result = await parser.parse(request);

      expect(result.dataset.features).toHaveLength(0);
      expect(result.dataset.meta.recordCount).toBe(0);
    });

    it('应处理带注释的行', async () => {
      const gffData = `##gff-version 3
##date generated by test
# This is a comment
##source Test
Test\t.\tgene\t100\t200\t.\t+\t.\tID=geneA

`;

      mockReadFileSync.mockReturnValueOnce(gffData);

      const request: FileParseRequest = {
        projectId: mockProjectId,
        filePath: 'test.gff3'
      };

      const result = await parser.parse(request);

      expect(result.dataset.features).toHaveLength(1);
    });

    it('应处理不同类型的特征', async () => {
      const gffData = `##gff-version 3
Test\t.\tgene\t100\t200\t.\t+\t.\tID=geneA
Test\t.\tCDS\t300\t500\t.\t+\t0\tID=cdsA
Test\t.\trRNA\t600\t700\t.\t+\t.\tID=rnaA
Test\t.\texon\t800\t900\t.\t+\t.\tID=exonA

`;

      mockReadFileSync.mockReturnValueOnce(gffData);

      const request: FileParseRequest = {
        projectId: mockProjectId,
        filePath: 'test.gff3'
      };

      const result = await parser.parse(request);

      expect(result.dataset.features).toHaveLength(4);
      expect(result.dataset.features.map(f => f.type)).toEqual([
        'gene',
        'CDS',
        'rRNA',
        'exon'
      ]);
    });

    it('应处理没有名称的属性', async () => {
      const gffData = `##gff-version 3
Test\t.\tgene\t100\t200\t.\t+\t.\tID=geneA

`;

      mockReadFileSync.mockReturnValueOnce(gffData);

      const request: FileParseRequest = {
        projectId: mockProjectId,
        filePath: 'test.gff3'
      };

      const result = await parser.parse(request);

      expect(result.dataset.features[0]).toMatchObject({
        name: 'geneA'
      });
    });

    it('应处理带引号的属性值', async () => {
      const gffData = `##gff-version 3
Test\t.\tgene\t100\t200\t.\t+\t.\tID=geneA;Name="Gene A";product="hypothetical protein"

`;

      mockReadFileSync.mockReturnValueOnce(gffData);

      const request: FileParseRequest = {
        projectId: mockProjectId,
        filePath: 'test.gff3'
      };

      const result = await parser.parse(request);

      expect(result.dataset.features[0].qualifiers).toMatchObject({
        Name: 'Gene A',
        product: 'hypothetical protein'
      });
    });

    it('应跳过无效行', async () => {
      const gffData = `##gff-version 3
invalid line
Test\t.\tgene\t100\t200\t.\t+\t.\tID=geneA

`;

      mockReadFileSync.mockReturnValueOnce(gffData);

      const request: FileParseRequest = {
        projectId: mockProjectId,
        filePath: 'test.gff3'
      };

      const result = await parser.parse(request);

      expect(result.dataset.features).toHaveLength(1);
    });
  });
});
